---
import { cn } from "@/utils/cn";
import type { HTMLAttributes } from "astro/types";

export interface Props extends HTMLAttributes<"div"> {
  /**
   * Maximum length of the OTP (number of slots)
   */
  maxLength: number;
  /**
   * Pattern to validate input (default: digits only)
   * Use "digits" for numbers only, "alphanumeric" for letters and numbers, or provide a custom regex
   */
  pattern?: "digits" | "alphanumeric" | string;
  /**
   * Whether the input is disabled
   */
  disabled?: boolean;
  /**
   * Initial value
   */
  value?: string;
  /**
   * Name attribute for form submission
   */
  name?: string;
}

const {
  maxLength,
  pattern = "digits",
  disabled = false,
  value = "",
  name,
  class: className,
  ...props
} = Astro.props;

// Convert pattern shortcuts to regex
const getPatternRegex = (p: string) => {
  if (p === "digits") return "^[0-9]*$";
  if (p === "alphanumeric") return "^[a-zA-Z0-9]*$";
  return p;
};

const patternRegex = getPatternRegex(pattern);

const classes = cn(
  "flex items-center gap-2",
  disabled && "opacity-50 cursor-not-allowed",
  className
);
---

<div
  class={classes}
  data-input-otp
  data-max-length={maxLength}
  data-pattern={patternRegex}
  data-disabled={disabled ? "true" : undefined}
  role="group"
  aria-label="One-time password input"
  {...props}
>
  <slot />
  {name && (
    <input
      type="hidden"
      name={name}
      value={value}
      data-otp-hidden-input
    />
  )}
</div>

<script>
  function initInputOTP() {
    document.querySelectorAll('[data-input-otp]').forEach((container) => {
      if (container.hasAttribute('data-otp-initialized')) return;
      container.setAttribute('data-otp-initialized', 'true');

      const slots = container.querySelectorAll('[data-otp-slot]') as NodeListOf<HTMLInputElement>;
      const hiddenInput = container.querySelector('[data-otp-hidden-input]') as HTMLInputElement | null;
      const pattern = new RegExp(container.getAttribute('data-pattern') || '^[0-9]*$');
      const isDisabled = container.hasAttribute('data-disabled');

      if (isDisabled) {
        slots.forEach(slot => {
          slot.disabled = true;
        });
        return;
      }

      // Update hidden input with combined value
      const updateHiddenInput = () => {
        if (hiddenInput) {
          const value = Array.from(slots).map(s => s.value).join('');
          hiddenInput.value = value;
        }
      };

      // Focus management
      const focusSlot = (index: number) => {
        if (index >= 0 && index < slots.length) {
          slots[index].focus();
          slots[index].select();
        }
      };

      slots.forEach((slot, index) => {
        // Handle input
        slot.addEventListener('input', (e) => {
          const input = e.target as HTMLInputElement;
          let value = input.value;

          // Validate against pattern
          if (value && !pattern.test(value)) {
            input.value = '';
            return;
          }

          // Take only first character
          if (value.length > 1) {
            value = value[0];
            input.value = value;
          }

          // Update state
          if (value) {
            slot.setAttribute('data-filled', 'true');
          } else {
            slot.removeAttribute('data-filled');
          }

          updateHiddenInput();

          // Auto-advance to next slot
          if (value && index < slots.length - 1) {
            focusSlot(index + 1);
          }
        });

        // Handle keydown for navigation
        slot.addEventListener('keydown', (e) => {
          const key = e.key;

          if (key === 'Backspace') {
            if (!slot.value && index > 0) {
              e.preventDefault();
              focusSlot(index - 1);
              slots[index - 1].value = '';
              slots[index - 1].removeAttribute('data-filled');
              updateHiddenInput();
            } else {
              slot.removeAttribute('data-filled');
            }
          } else if (key === 'ArrowLeft' && index > 0) {
            e.preventDefault();
            focusSlot(index - 1);
          } else if (key === 'ArrowRight' && index < slots.length - 1) {
            e.preventDefault();
            focusSlot(index + 1);
          } else if (key === 'Delete') {
            slot.value = '';
            slot.removeAttribute('data-filled');
            updateHiddenInput();
          }
        });

        // Handle paste
        slot.addEventListener('paste', (e) => {
          e.preventDefault();
          const pasteData = e.clipboardData?.getData('text') || '';
          
          // Validate pasted content
          if (!pattern.test(pasteData)) return;

          // Distribute pasted characters across slots starting from current
          const chars = pasteData.split('');
          let currentIndex = index;
          
          chars.forEach((char) => {
            if (currentIndex < slots.length && pattern.test(char)) {
              slots[currentIndex].value = char;
              slots[currentIndex].setAttribute('data-filled', 'true');
              currentIndex++;
            }
          });

          updateHiddenInput();

          // Focus the next empty slot or last filled slot
          const nextEmpty = Array.from(slots).findIndex(s => !s.value);
          focusSlot(nextEmpty === -1 ? slots.length - 1 : nextEmpty);
        });

        // Handle focus
        slot.addEventListener('focus', () => {
          slot.select();
          container.setAttribute('data-focused', 'true');
        });

        slot.addEventListener('blur', () => {
          // Check if focus moved outside the container
          setTimeout(() => {
            const activeElement = document.activeElement;
            const isStillInContainer = Array.from(slots).includes(activeElement as HTMLInputElement);
            if (!isStillInContainer) {
              container.removeAttribute('data-focused');
            }
          }, 0);
        });
      });

      // Set initial values if provided
      const initialValue = hiddenInput?.value || '';
      if (initialValue) {
        initialValue.split('').forEach((char, i) => {
          if (i < slots.length) {
            slots[i].value = char;
            slots[i].setAttribute('data-filled', 'true');
          }
        });
      }
    });
  }

  // Initialize on load
  initInputOTP();

  // Re-initialize on page navigation (for Astro view transitions)
  document.addEventListener('astro:page-load', initInputOTP);
</script>
