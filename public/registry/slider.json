{
  "name": "slider",
  "description": "A range input slider",
  "category": "form",
  "dependencies": [],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "name": "Slider.astro",
      "path": "slider/Slider.astro",
      "content": "---\nimport { cn } from \"@/utils/cn\";\nimport type { HTMLAttributes } from \"astro/types\";\n\nexport interface Props extends HTMLAttributes<\"div\"> {\n  defaultValue?: number[];\n  min?: number;\n  max?: number;\n  step?: number;\n  disabled?: boolean;\n  orientation?: \"horizontal\" | \"vertical\";\n  name?: string;\n}\n\nconst {\n  defaultValue = [0],\n  min = 0,\n  max = 100,\n  step = 1,\n  disabled = false,\n  orientation = \"horizontal\",\n  name,\n  class: className,\n  ...props\n} = Astro.props;\n\nconst isVertical = orientation === \"vertical\";\nconst isRange = defaultValue.length > 1;\n\nconst containerClasses = cn(\n  \"relative flex touch-none select-none justify-center\",\n  isVertical ? \"h-full min-h-32 w-5\" : \"w-full h-5 items-center\",\n  disabled && \"opacity-50 pointer-events-none\",\n  className\n);\n\nconst trackClasses = cn(\n  \"relative overflow-hidden rounded-full bg-secondary\",\n  isVertical ? \"w-1 h-full\" : \"h-1 w-full\"\n);\n---\n\n<div\n  data-slider\n  data-orientation={orientation}\n  data-disabled={disabled ? \"true\" : undefined}\n  data-default-value={JSON.stringify(defaultValue)}\n  data-min={min}\n  data-max={max}\n  data-step={step}\n  data-name={name}\n  class={containerClasses}\n  role=\"slider\"\n  aria-valuemin={min}\n  aria-valuemax={max}\n  aria-valuenow={defaultValue[0]}\n  aria-orientation={orientation}\n  aria-disabled={disabled}\n  tabindex={disabled ? -1 : 0}\n  {...props}\n>\n  <div class={trackClasses} data-slider-track>\n    <div\n      data-slider-range\n      class={cn(\n        \"absolute bg-primary\",\n        isVertical ? \"w-full\" : \"h-full\"\n      )}\n    ></div>\n  </div>\n  {defaultValue.map((_, index) => (\n    <div\n      data-slider-thumb\n      data-index={index}\n      class={cn(\n        \"absolute block size-3.5 rounded-full border-2 border-primary bg-background\",\n        \"ring-offset-background transition-colors\",\n        \"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n        \"disabled:pointer-events-none disabled:opacity-50\",\n        \"cursor-grab active:cursor-grabbing\"\n      )}\n      tabindex={disabled ? -1 : 0}\n    />\n  ))}\n</div>\n\n<style>\n  [data-slider-thumb] {\n    z-index: 1;\n  }\n  \n  [data-slider][data-orientation=\"horizontal\"] [data-slider-thumb] {\n    top: 50%;\n    transform: translate(-50%, -50%);\n  }\n  \n  [data-slider][data-orientation=\"vertical\"] [data-slider-thumb] {\n    left: 50%;\n    transform: translate(-50%, 0);\n  }\n</style>\n\n<script>\n  function initSliders() {\n    document.querySelectorAll('[data-slider]').forEach((slider) => {\n      if (slider.hasAttribute('data-initialized')) return;\n      slider.setAttribute('data-initialized', 'true');\n      \n      const track = slider.querySelector('[data-slider-track]') as HTMLElement;\n      const range = slider.querySelector('[data-slider-range]') as HTMLElement;\n      const thumbs = slider.querySelectorAll('[data-slider-thumb]') as NodeListOf<HTMLElement>;\n      \n      const min = parseFloat(slider.getAttribute('data-min') || '0');\n      const max = parseFloat(slider.getAttribute('data-max') || '100');\n      const step = parseFloat(slider.getAttribute('data-step') || '1');\n      const isVertical = slider.getAttribute('data-orientation') === 'vertical';\n      const isDisabled = slider.getAttribute('data-disabled') === 'true';\n      const name = slider.getAttribute('data-name');\n      \n      let values: number[] = JSON.parse(slider.getAttribute('data-default-value') || '[0]');\n      \n      if (isDisabled) return;\n      \n      function getPercent(value: number): number {\n        return ((value - min) / (max - min)) * 100;\n      }\n      \n      function getValueFromPercent(percent: number): number {\n        const rawValue = (percent / 100) * (max - min) + min;\n        const steppedValue = Math.round(rawValue / step) * step;\n        return Math.min(max, Math.max(min, steppedValue));\n      }\n      \n      function updateUI() {\n        const sortedValues = [...values].sort((a, b) => a - b);\n        \n        thumbs.forEach((thumb, i) => {\n          const percent = getPercent(values[i]);\n          if (isVertical) {\n            thumb.style.bottom = `${percent}%`;\n          } else {\n            thumb.style.left = `${percent}%`;\n          }\n        });\n        \n        // Update range\n        if (values.length === 1) {\n          const percent = getPercent(values[0]);\n          if (isVertical) {\n            range.style.bottom = '0';\n            range.style.height = `${percent}%`;\n          } else {\n            range.style.left = '0';\n            range.style.width = `${percent}%`;\n          }\n        } else {\n          const minPercent = getPercent(sortedValues[0]);\n          const maxPercent = getPercent(sortedValues[sortedValues.length - 1]);\n          if (isVertical) {\n            range.style.bottom = `${minPercent}%`;\n            range.style.height = `${maxPercent - minPercent}%`;\n          } else {\n            range.style.left = `${minPercent}%`;\n            range.style.width = `${maxPercent - minPercent}%`;\n          }\n        }\n        \n        // Update ARIA\n        slider.setAttribute('aria-valuenow', values.join(','));\n        \n        // Dispatch change event\n        slider.dispatchEvent(new CustomEvent('change', { detail: { values } }));\n      }\n      \n      function getPercentFromEvent(e: MouseEvent | TouchEvent): number {\n        const rect = track.getBoundingClientRect();\n        const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n        const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n        \n        if (isVertical) {\n          const percent = ((rect.bottom - clientY) / rect.height) * 100;\n          return Math.min(100, Math.max(0, percent));\n        } else {\n          const percent = ((clientX - rect.left) / rect.width) * 100;\n          return Math.min(100, Math.max(0, percent));\n        }\n      }\n      \n      // Thumb dragging\n      thumbs.forEach((thumb, index) => {\n        let isDragging = false;\n        \n        function startDrag(e: MouseEvent | TouchEvent) {\n          e.preventDefault();\n          isDragging = true;\n          thumb.focus();\n          document.addEventListener('mousemove', onDrag);\n          document.addEventListener('mouseup', stopDrag);\n          document.addEventListener('touchmove', onDrag);\n          document.addEventListener('touchend', stopDrag);\n        }\n        \n        function onDrag(e: MouseEvent | TouchEvent) {\n          if (!isDragging) return;\n          const percent = getPercentFromEvent(e);\n          values[index] = getValueFromPercent(percent);\n          updateUI();\n        }\n        \n        function stopDrag() {\n          isDragging = false;\n          document.removeEventListener('mousemove', onDrag);\n          document.removeEventListener('mouseup', stopDrag);\n          document.removeEventListener('touchmove', onDrag);\n          document.removeEventListener('touchend', stopDrag);\n        }\n        \n        thumb.addEventListener('mousedown', startDrag);\n        thumb.addEventListener('touchstart', startDrag);\n        \n        // Keyboard navigation\n        thumb.addEventListener('keydown', (e) => {\n          let newValue = values[index];\n          \n          switch (e.key) {\n            case 'ArrowRight':\n            case 'ArrowUp':\n              e.preventDefault();\n              newValue = Math.min(max, values[index] + step);\n              break;\n            case 'ArrowLeft':\n            case 'ArrowDown':\n              e.preventDefault();\n              newValue = Math.max(min, values[index] - step);\n              break;\n            case 'Home':\n              e.preventDefault();\n              newValue = min;\n              break;\n            case 'End':\n              e.preventDefault();\n              newValue = max;\n              break;\n            default:\n              return;\n          }\n          \n          values[index] = newValue;\n          updateUI();\n        });\n      });\n      \n      // Click on track\n      track.addEventListener('click', (e) => {\n        const percent = getPercentFromEvent(e);\n        const newValue = getValueFromPercent(percent);\n        \n        // Find closest thumb\n        let closestIndex = 0;\n        let closestDistance = Infinity;\n        values.forEach((v, i) => {\n          const distance = Math.abs(v - newValue);\n          if (distance < closestDistance) {\n            closestDistance = distance;\n            closestIndex = i;\n          }\n        });\n        \n        values[closestIndex] = newValue;\n        updateUI();\n        thumbs[closestIndex].focus();\n      });\n      \n      // Initial UI update\n      updateUI();\n    });\n  }\n  \n  initSliders();\n  document.addEventListener('astro:page-load', initSliders);\n</script>\n"
    }
  ]
}
